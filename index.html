<!doctype html>
<html>
    <head>
        <title>C U L8er: Video Game Transformation</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
        <style>
            body {
                margin: 0;
                padding: 0;
                overflow: hidden;
                background-color: #000;
                font-family: Arial, sans-serif;
            }
            canvas {
                display: block;
            }
            #canvas-container {
                position: relative;
                width: 100%;
                height: 100vh;
            }
            .overlay {
                position: absolute;
                color: #fff;
                z-index: 100;
                text-align: center;
                transition: transform 0.2s ease-out;
                background-color: rgba(0, 0, 0, 0.5);
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 0 20px rgba(128, 0, 128, 0.5); /* Purple box shadow */
                max-width: 400px;
                width: 100%;
            }
            h1 {
                font-size: 32px;
                margin: 0 0 10px 0;
                text-shadow: 0 0 8px rgba(255, 255, 255, 0.7);
            }
            p {
                font-size: 16px;
                margin: 0 0 20px 0;
                opacity: 0.8;
            }
            .button {
                display: inline-block;
                padding: 10px 20px;
                background-color: rgba(255, 215, 0, 0.7);
                color: #000;
                text-decoration: none;
                border-radius: 5px;
                font-weight: bold;
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
                transition: all 0.3s ease;
                margin: 5px;
            }
            .button:hover {
                background-color: rgba(255, 215, 0, 1);
                transform: scale(1.05);
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.9);
            }
            .button.solution {
                background-color: rgba(
                    135,
                    206,
                    235,
                    0.7
                ); /* Light blue background */
                color: #000; /* Black text */
                box-shadow: 0 0 10px rgba(135, 206, 235, 0.7); /* Light blue glow */
            }

            .button.solution:hover {
                background-color: rgba(
                    135,
                    206,
                    235,
                    1
                ); /* Brighter light blue on hover */
                box-shadow: 0 0 15px rgba(135, 206, 235, 0.9); /* More intense glow on hover */
            }

            .button.process {
                background-color: rgba(
                    128,
                    0,
                    128,
                    0.7
                ); /* Purple background */
                color: #fff; /* White text */
                box-shadow: 0 0 10px rgba(128, 0, 128, 0.7); /* Purple glow */
            }

            .button.process:hover {
                background-color: rgba(
                    128,
                    0,
                    128,
                    1
                ); /* Brighter purple on hover */
                box-shadow: 0 0 15px rgba(128, 0, 128, 0.9); /* More intense glow on hover */
            }
        </style>
    </head>
    <body>
        <div id="canvas-container">
            <div class="overlay">
                <h1>C U L8er</h1>
                <p>
                    Cosmic Universal Lithography 8er<br />(Video Game
                    Transformation)
                </p>
                <a href="https://wrand.cc" class="button" target="_blank"
                    >R&D IDEA</a
                >
                <a href="https://webtracks.click" class="button" target="_blank"
                    >TRACK IDEA</a
                >
                <br />
                <a href="https://webhost.systems" class="button" target="_blank"
                    >HOST IDEA</a
                >
                <a href="https://bendscript.com" class="button" target="_blank"
                    >SCRIPT IDEA</a
                >
                <br />
                <a
                    href="https://istrav.com"
                    class="button solution"
                    target="_blank"
                    >WEB SOLUTIONS</a
                >
                <br />
                <a
                    href="https://subvind.com"
                    class="button solution"
                    target="_blank"
                    >COMMUNITY SOLUTIONS</a
                >
                <br />
                <a
                    href="https://ticktickclock.com"
                    class="button process"
                    target="_blank"
                    >CLOCK PROCESSES</a
                >
            </div>
        </div>

        <script>
            // Add these variables at the top of your script
            let mouseX = 0;
            let mouseY = 0;
            let hoveredBulb = null;
            let isMouseDown = false;

            // Create a canvas for stars and effects
            const effectsCanvas = document.createElement("canvas");
            effectsCanvas.width = window.innerWidth;
            effectsCanvas.height = window.innerHeight;
            effectsCanvas.style.position = "absolute";
            effectsCanvas.style.top = "0";
            effectsCanvas.style.left = "0";
            effectsCanvas.style.zIndex = "1";
            document
                .getElementById("canvas-container")
                .appendChild(effectsCanvas);
            const effectsCtx = effectsCanvas.getContext("2d");

            // 2. Now add the event listeners right after creating the canvas:
            // Add mouse event listeners to the canvas
            effectsCanvas.addEventListener("mousemove", function (event) {
                mouseX = event.clientX;
                mouseY = event.clientY;

                // Check if mouse is over any lightbulb
                hoveredBulb = null;
                for (let i = 0; i < lightbulbs.length; i++) {
                    const bulb = lightbulbs[i];
                    const dx = mouseX - bulb.position.x;
                    const dy = mouseY - bulb.position.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < bulbSize) {
                        hoveredBulb = bulb;
                        effectsCanvas.style.cursor = "pointer";
                        break;
                    }
                }

                if (!hoveredBulb) {
                    effectsCanvas.style.cursor = "default";
                }
            });

            effectsCanvas.addEventListener("mousedown", function () {
                isMouseDown = true;
            });

            effectsCanvas.addEventListener("mouseup", function () {
                if (isMouseDown && hoveredBulb) {
                    // Open link when lightbulb is clicked
                    window.location.href = "https://lifecycle.c-u-l8er.link";
                }
                isMouseDown = false;
            });

            // Module aliases for Matter.js
            const Engine = Matter.Engine,
                Render = Matter.Render,
                Runner = Matter.Runner,
                Bodies = Matter.Bodies,
                Composite = Matter.Composite,
                Body = Matter.Body,
                Events = Matter.Events;

            // Create engine and world
            const engine = Engine.create({
                gravity: { x: 0, y: 0 }, // Zero gravity for space
            });
            const world = engine.world;

            // Create renderer
            const render = Render.create({
                element: document.getElementById("canvas-container"),
                engine: engine,
                options: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    wireframes: false,
                    background: "transparent",
                    pixelRatio: window.devicePixelRatio,
                },
            });
            render.canvas.style.zIndex = "2";

            // Run the renderer
            Render.run(render);

            // Create a runner
            const runner = Runner.create();
            Runner.run(runner, engine);

            // Lightbulb data structure
            const lightbulbs = [];
            // Same color for all lightbulbs
            const bulbColor = "#87CEEB"; // Light blue color

            // Connection distance threshold - increased for larger bulbs
            const connectionDistance = 300;

            // MODIFIED: Increase size by 2.5 times - adjusted SVG paths
            const bulbSize = 50; // Original was 20, now 50 (2.5x larger)

            // SVG lightbulb path (scaled up 2.5x from original)
            const lightbulbSVG = {
                // SVG data for a proper lightbulb shape - scaled up 2.5x
                bulbPath:
                    "M0,-50 C-27.5,-50 -50,-27.5 -50,0 C-50,27.5 -27.5,50 0,50 C27.5,50 50,27.5 50,0 C50,-27.5 27.5,-50 0,-50",
                basePath: "M-17.5,50 L-17.5,70 L17.5,70 L17.5,50",
                filamentPath: "M-12.5,0 C-12.5,-12.5 12.5,-12.5 12.5,0",
            };

            // Modify the createLightbulb function to include a hovered property
            function createLightbulb(x, y, number) {
                // Convert number to 3-digit binary
                const binaryStr = number.toString(2).padStart(3, "0");

                // Glass bulb (main body) - 2.5x larger radius
                const bulb = Bodies.circle(x, y, bulbSize, {
                    friction: 0,
                    frictionAir: 0, // No air friction for infinite movement
                    restitution: 1,
                    render: {
                        fillStyle: bulbColor,
                        opacity: 0.7,
                    },
                });

                // Add properties for drawing glow and binary digits later
                bulb.color = bulbColor;
                bulb.glowIntensity = 0.7;
                bulb.binaryStr = binaryStr;
                bulb.isHovered = false; // Add this property

                lightbulbs.push(bulb);
                return bulb;
            }

            // MODIFIED: Create only 8 lightbulbs (numbered 0-7)
            for (let i = 0; i < 8; i++) {
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;

                const lightbulb = createLightbulb(x, y, i);

                // Add random velocity
                Body.setVelocity(lightbulb, {
                    x: (Math.random() - 0.5) * 3,
                    y: (Math.random() - 0.5) * 3,
                });

                Composite.add(world, lightbulb);
            }

            // Setup for the bouncing overlay
            const overlay = document.querySelector(".overlay");
            const overlayWidth = overlay.offsetWidth;
            const overlayHeight = overlay.offsetHeight;

            // Initial position and velocity for the overlay
            let overlayX = Math.random() * (window.innerWidth - overlayWidth);
            let overlayY = Math.random() * (window.innerHeight - overlayHeight);
            let overlayVX = 0.75; // X velocity
            let overlayVY = 0.5; // Y velocity

            // Apply initial position
            overlay.style.left = `${overlayX}px`;
            overlay.style.top = `${overlayY}px`;

            // Star data with direction for movement
            const stars = [];
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    radius: Math.random() * 1.5 + 0.5,
                    opacity: Math.random() * 0.8 + 0.2,
                    twinkleSpeed: Math.random() * 0.05 + 0.01,
                    // Add very slow movement to stars
                    vx: (Math.random() - 0.5) * 0.1,
                    vy: (Math.random() - 0.5) * 0.1,
                });
            }

            // Add before update event to handle wrap-around
            Events.on(engine, "beforeUpdate", function () {
                const width = window.innerWidth;
                const height = window.innerHeight;

                // Check each lightbulb position and wrap if needed
                for (let i = 0; i < lightbulbs.length; i++) {
                    const bulb = lightbulbs[i];
                    const bulbX = bulb.position.x;
                    const bulbY = bulb.position.y;

                    // Wrap horizontally - adjusted for larger size
                    if (bulbX < -120) {
                        Body.setPosition(bulb, {
                            x: width + 120,
                            y: bulbY,
                        });
                    } else if (bulbX > width + 120) {
                        Body.setPosition(bulb, {
                            x: -120,
                            y: bulbY,
                        });
                    }

                    // Wrap vertically - adjusted for larger size
                    if (bulbY < -120) {
                        Body.setPosition(bulb, {
                            x: bulbX,
                            y: height + 120,
                        });
                    } else if (bulbY > height + 120) {
                        Body.setPosition(bulb, {
                            x: bulbX,
                            y: -120,
                        });
                    }

                    // Maintain constant velocity (to counteract any slowdowns)
                    const velocity = bulb.velocity;
                    const speed = Math.sqrt(
                        velocity.x * velocity.x + velocity.y * velocity.y,
                    );

                    // Only boost if speed drops below original level
                    if (speed < 2) {
                        const direction = {
                            x: velocity.x / speed,
                            y: velocity.y / speed,
                        };

                        Body.setVelocity(bulb, {
                            x: direction.x * 3,
                            y: direction.y * 3,
                        });
                    }
                }
            });

            // Function to draw a path with transformation
            function drawPath(ctx, path, x, y, rotation = 0) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);

                const pathData = new Path2D(path);
                ctx.fill(pathData);

                ctx.restore();
            }

            // Update overlay position (bouncing effect)
            function updateOverlayPosition() {
                // Move the overlay according to its velocity
                overlayX += overlayVX;
                overlayY += overlayVY;

                // Get current window dimensions
                const maxX = window.innerWidth - overlayWidth;
                const maxY = window.innerHeight - overlayHeight;

                // Bounce off the edges
                if (overlayX <= 0) {
                    overlayX = 0;
                    overlayVX = Math.abs(overlayVX);
                } else if (overlayX >= maxX) {
                    overlayX = maxX;
                    overlayVX = -Math.abs(overlayVX);
                }

                if (overlayY <= 0) {
                    overlayY = 0;
                    overlayVY = Math.abs(overlayVY);
                } else if (overlayY >= maxY) {
                    overlayY = maxY;
                    overlayVY = -Math.abs(overlayVY);
                }

                // Apply the new position
                overlay.style.left = `${overlayX}px`;
                overlay.style.top = `${overlayY}px`;

                // Add a slight rotation based on direction
                const angle =
                    Math.atan2(overlayVY, overlayVX) * (180 / Math.PI);
                overlay.style.transform = `rotate(${angle * 0.05}deg)`;

                // Schedule the next update
                requestAnimationFrame(updateOverlayPosition);
            }

            // Start the overlay animation
            updateOverlayPosition();

            // Animation function for stars, glows, letters, and connections
            function animate() {
                // Clear the canvas
                effectsCtx.clearRect(
                    0,
                    0,
                    effectsCanvas.width,
                    effectsCanvas.height,
                );

                // Update and draw stars
                for (let i = 0; i < stars.length; i++) {
                    const star = stars[i];

                    // Move the star
                    star.x += star.vx;
                    star.y += star.vy;

                    // Wrap the stars when they go off screen
                    if (star.x < 0) star.x = effectsCanvas.width;
                    if (star.x > effectsCanvas.width) star.x = 0;
                    if (star.y < 0) star.y = effectsCanvas.height;
                    if (star.y > effectsCanvas.height) star.y = 0;

                    // Twinkle effect
                    star.opacity =
                        0.2 +
                        (Math.sin(Date.now() * star.twinkleSpeed) + 1) * 0.4;

                    effectsCtx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                    effectsCtx.beginPath();
                    effectsCtx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                    effectsCtx.fill();
                }

                // MODIFIED: Draw gold connections between nearby lightbulbs
                for (let i = 0; i < lightbulbs.length; i++) {
                    const bulb1 = lightbulbs[i];

                    for (let j = i + 1; j < lightbulbs.length; j++) {
                        const bulb2 = lightbulbs[j];

                        // Calculate distance between bulbs
                        const dx = bulb1.position.x - bulb2.position.x;
                        const dy = bulb1.position.y - bulb2.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // Draw connection if the bulbs are close enough
                        if (distance < connectionDistance) {
                            // Adjust opacity based on distance
                            const opacity = 1 - distance / connectionDistance;

                            // MODIFIED: Changed connections to gold
                            effectsCtx.strokeStyle = `rgba(255, 215, 0, ${opacity * 0.7})`;
                            effectsCtx.lineWidth = 3; // Slightly thicker gold lines
                            effectsCtx.beginPath();
                            effectsCtx.moveTo(
                                bulb1.position.x,
                                bulb1.position.y,
                            );
                            effectsCtx.lineTo(
                                bulb2.position.x,
                                bulb2.position.y,
                            );
                            effectsCtx.stroke();
                        }
                    }
                }

                // Draw each lightbulb using SVG paths
                for (let i = 0; i < lightbulbs.length; i++) {
                    const bulb = lightbulbs[i];
                    const intensity =
                        0.5 + Math.sin(Date.now() * 0.002 + i) * 0.2;

                    // Check if this bulb is being hovered over
                    bulb.isHovered = hoveredBulb === bulb;

                    // Set the bulb color based on hover state
                    const currentBulbColor = bulb.isHovered
                        ? "#800080"
                        : bulbColor; // Purple if hovered, light blue otherwise

                    // Parse color to RGB for glow
                    let r, g, b;
                    if (bulb.isHovered) {
                        // Purple color when hovered (128, 0, 128)
                        r = 128;
                        g = 0;
                        b = 128;
                    } else {
                        // Original light blue color
                        r = 135;
                        g = 206;
                        b = 235;
                    }

                    // Create radial gradient for glow - scaled up for larger bulbs
                    const gradient = effectsCtx.createRadialGradient(
                        bulb.position.x,
                        bulb.position.y,
                        12.5, // Scaled up
                        bulb.position.x,
                        bulb.position.y,
                        100, // Scaled up
                    );

                    gradient.addColorStop(
                        0,
                        `rgba(${r}, ${g}, ${b}, ${0.7 * intensity * bulb.glowIntensity})`,
                    );
                    gradient.addColorStop(1, "rgba(0, 0, 0, 0)");

                    effectsCtx.fillStyle = gradient;
                    effectsCtx.beginPath();
                    effectsCtx.arc(
                        bulb.position.x,
                        bulb.position.y,
                        100, // Scaled up
                        0,
                        Math.PI * 2,
                    );
                    effectsCtx.fill();

                    // Draw glass bulb using SVG path - using current color based on hover state
                    effectsCtx.fillStyle = currentBulbColor;
                    drawPath(
                        effectsCtx,
                        lightbulbSVG.bulbPath,
                        bulb.position.x,
                        bulb.position.y,
                    );

                    // Draw a metal base using SVG path
                    effectsCtx.fillStyle = "#777";
                    drawPath(
                        effectsCtx,
                        lightbulbSVG.basePath,
                        bulb.position.x,
                        bulb.position.y,
                    );

                    // Add golden glow lines around the bulb - scaled up
                    const glowIntensity =
                        0.4 + Math.sin(Date.now() * 0.003 + i) * 0.2;

                    // Change glow lines color based on hover state
                    if (bulb.isHovered) {
                        effectsCtx.strokeStyle = `rgba(135, 206, 235, ${glowIntensity})`; // Purple glow when hovered
                    } else {
                        effectsCtx.strokeStyle = `rgba(255, 215, 0, ${glowIntensity})`; // Gold glow normally
                    }

                    effectsCtx.lineWidth = 2;

                    // Draw 3 concentric circles with varying radii for glow effect - scaled up
                    for (let radius = 62.5; radius <= 87.5; radius += 12.5) {
                        effectsCtx.beginPath();
                        effectsCtx.arc(
                            bulb.position.x,
                            bulb.position.y,
                            radius,
                            0,
                            Math.PI * 2,
                        );
                        effectsCtx.stroke();
                    }

                    // Draw binary digits with color based on hover state
                    effectsCtx.fillStyle = bulb.isHovered
                        ? "#FFD700"
                        : "purple"; // Gold text if hovered, purple normally
                    effectsCtx.font = "bold 20px monospace"; // Monospace font for binary digits
                    effectsCtx.textAlign = "center";
                    effectsCtx.textBaseline = "middle";

                    // Position the digits vertically inside the bulb
                    const digits = bulb.binaryStr.split("");
                    effectsCtx.fillText(
                        digits[0],
                        bulb.position.x,
                        bulb.position.y - 15,
                    );
                    effectsCtx.fillText(
                        digits[1],
                        bulb.position.x,
                        bulb.position.y,
                    );
                    effectsCtx.fillText(
                        digits[2],
                        bulb.position.x,
                        bulb.position.y + 15,
                    );
                }

                requestAnimationFrame(animate);
            }

            // Start animation
            animate();

            // Button glow animation
            setInterval(() => {
                const button = document.querySelector(".button");
                const currentGlow = Math.floor(Math.random() * 5) + 5; // Random glow between 5-10px
                button.style.boxShadow = `0 0 ${currentGlow}px rgba(135, 206, 235, 0.8)`;
            }, 1000);

            // Handle window resize
            window.addEventListener("resize", function () {
                // Update canvases
                render.canvas.width = window.innerWidth;
                render.canvas.height = window.innerHeight;
                effectsCanvas.width = window.innerWidth;
                effectsCanvas.height = window.innerHeight;

                // Update renderer
                render.options.width = window.innerWidth;
                render.options.height = window.innerHeight;

                // Make sure the overlay stays within bounds after resize
                const maxX = window.innerWidth - overlayWidth;
                const maxY = window.innerHeight - overlayHeight;

                if (overlayX > maxX) {
                    overlayX = maxX;
                    overlay.style.left = `${overlayX}px`;
                }

                if (overlayY > maxY) {
                    overlayY = maxY;
                    overlay.style.top = `${overlayY}px`;
                }
            });
        </script>
    </body>
</html>
