<!doctype html>
<html>
    <head>
        <link
            rel="apple-touch-icon"
            sizes="180x180"
            href="/apple-touch-icon.png"
        />
        <link
            rel="icon"
            type="image/png"
            sizes="32x32"
            href="/favicon-32x32.png"
        />
        <link
            rel="icon"
            type="image/png"
            sizes="16x16"
            href="/favicon-16x16.png"
        />
        <link rel="manifest" href="/site.webmanifest" />

        <title>C U L8er: Concept Ultra Load-8alancer</title>

        <meta charset="UTF-8" />
        <meta
            name="description"
            content="See you later or c u l8er is (Concept Ultra Load-8alancer) an agency for ideation."
        />
        <meta
            name="keywords"
            content="See You Later, Video Game, Transformation, Concept, Ultra, Lithography, Ideation, Agency"
        />
        <meta name="author" content="Travis Burandt" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
        <style>
            body {
                margin: 0;
                padding: 0;
                overflow: hidden;
                background-color: #000;
                font-family: Arial, sans-serif;
            }
            canvas {
                display: block;
            }
            #canvas-container {
                position: relative;
                width: 100%;
                height: 100vh;
            }
            .card-container {
                position: absolute;
                z-index: 100;
                max-width: 450px;
                width: 100%;
                height: 450px;
                padding: 20px;
            }

            .card-wrapper {
                position: relative;
                width: 100%;
                height: 100%;
                perspective: 1200px;
            }

            .card {
                position: relative;
                width: 100%;
                height: 100%;
                transform-style: preserve-3d;
                transition: transform 0.6s ease-in-out;
                cursor: pointer;
            }

            .card.flipped {
                transform: rotateY(180deg);
            }

            .card-front,
            .card-back {
                position: absolute;
                width: 100%;
                height: 100%;
                backface-visibility: hidden;
                border-radius: 10px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .card-front {
                background-color: transparent;
                box-shadow: none;
                padding: 20px;
            }

            .card-back {
                background-color: rgba(0, 0, 0, 0.5);
                box-shadow: 0 0 20px rgba(220, 20, 60, 0.5);
                transform: rotateY(180deg);
                padding: 20px;
            }

            .logo-image {
                max-width: 100%;
                max-height: 100%;
                width: 400px;
                height: 400px;
                object-fit: contain;
                border-radius: 10px;
                box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
            }

            .overlay-content {
                color: #fff;
                text-align: center;
                width: 100%;
            }
            h1 {
                font-size: 32px;
                margin: 0 0 10px 0;
                text-shadow: 0 0 8px rgba(255, 255, 255, 0.7);
            }
            p {
                font-size: 16px;
                margin: 0 0 20px 0;
                opacity: 0.8;
            }
            .button {
                display: inline-block;
                padding: 10px 20px;
                background-color: rgba(255, 215, 0, 0.7);
                color: #000;
                text-decoration: none;
                border-radius: 5px;
                font-weight: bold;
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
                transition: all 0.3s ease;
                margin: 5px;
            }
            .button:hover {
                background-color: rgba(255, 215, 0, 1);
                transform: scale(1.05);
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.9);
            }
            .button.solution {
                background-color: rgba(
                    135,
                    206,
                    235,
                    0.7
                ); /* Light blue background */
                color: #000; /* Black text */
                box-shadow: 0 0 10px rgba(135, 206, 235, 0.7); /* Light blue glow */
            }

            .button.solution:hover {
                background-color: rgba(
                    135,
                    206,
                    235,
                    1
                ); /* Brighter light blue on hover */
                box-shadow: 0 0 15px rgba(135, 206, 235, 0.9); /* More intense glow on hover */
            }

            .button.power {
                background-color: rgba(
                    128,
                    0,
                    128,
                    0.7
                ); /* Purple background */
                color: #fff; /* White text */
                box-shadow: 0 0 10px rgba(128, 0, 128, 0.7); /* Purple glow */
            }

            .button.power:hover {
                background-color: rgba(
                    128,
                    0,
                    128,
                    1
                ); /* Brighter purple on hover */
                box-shadow: 0 0 15px rgba(128, 0, 128, 0.9); /* More intense glow on hover */
            }

            .button.main {
                background-color: rgba(220, 20, 60, 0.9); /* Red background */
                color: #fff; /* White text */
                box-shadow: 0 0 10px rgba(220, 20, 60, 0.7); /* Red glow */
            }

            .button.main:hover {
                background-color: rgba(220, 20, 60, 1); /* Brighter red on hover */
                box-shadow: 0 0 15px rgba(220, 20, 60, 0.9); /* More intense red glow on hover */
            }

            .button.export {
                background-color: rgba(255, 255, 255, 0.9); /* White background */
                color: #000; /* Black text */
                box-shadow: 0 0 10px rgba(255, 255, 255, 0.7); /* White glow */
            }

            .button.export:hover {
                background-color: rgba(255, 255, 255, 1); /* Brighter white on hover */
                box-shadow: 0 0 15px rgba(255, 255, 255, 0.9); /* More intense glow on hover */
            }

            .button.ideation {
                background-color: rgba(0, 128, 0, 0.7); /* Green background */
                color: #fff; /* White text */
                box-shadow: 0 0 10px rgba(0, 128, 0, 0.7); /* Green glow */
            }

            .button.ideation:hover {
                background-color: rgba(0, 128, 0, 1); /* Brighter green on hover */
                box-shadow: 0 0 15px rgba(0, 128, 0, 0.9); /* More intense glow on hover */
            }

            .button.control {
                background-color: rgba(0, 128, 0, 0.7); /* Green background */
                color: #fff; /* White text */
                box-shadow: 0 0 10px rgba(0, 128, 0, 0.7); /* Green glow */
            }

            .button.control:hover {
                background-color: rgba(0, 128, 0, 1); /* Brighter green on hover */
                box-shadow: 0 0 15px rgba(0, 128, 0, 0.9); /* More intense glow on hover */
            }

            .button.game {
                background-color: rgba(128, 128, 128, 0.7); /* Grey background */
                color: #fff; /* White text */
                box-shadow: 0 0 10px rgba(128, 128, 128, 0.7); /* Grey glow */
            }

            .button.game:hover {
                background-color: rgba(128, 128, 128, 1); /* Brighter grey on hover */
                box-shadow: 0 0 15px rgba(128, 128, 128, 0.9); /* More intense glow on hover */
            }

            .button.rnd {
                background-color: rgba(139, 69, 19, 0.7); /* Brown background */
                color: #fff; /* White text */
                box-shadow: 0 0 10px rgba(139, 69, 19, 0.7); /* Brown glow */
            }

            .button.rnd:hover {
                background-color: rgba(139, 69, 19, 1); /* Brighter brown on hover */
                box-shadow: 0 0 15px rgba(139, 69, 19, 0.9); /* More intense glow on hover */
            }
        </style>
    </head>
    <body>
        <div id="canvas-container">
            <div class="card-container">
                <div class="card-wrapper">
                    <div class="card">
                        <div class="card-front">
                            <img src="logo.png" alt="C U L8er Logo" class="logo-image" />
                        </div>
                        <div class="card-back">
                            <div class="overlay-content">
                                <h1>C U L8er</h1>
                                <p>
                                    (Concept Ultra Load-8alancer)<br />
                                </p>
                                <a href="https://traaviis.com" class="button main" target="_blank">INTELLIGENCE</a>
                                <br />
                                <a href="https://ampersandboxdesign.com" class="button" target="_blank"
                                    >DESIGN</a
                                >
                                <a href="https://wrand.cc" class="button rnd" target="_blank"
                                    >R&D</a
                                >
                                <br />
                                <a
                                    href="https://istrav.com"
                                    class="button solution"
                                    target="_blank"
                                    >WEB SOLUTIONS</a
                                >
                                <br />
                                <a
                                    href="https://subvind.com"
                                    class="button solution"
                                    target="_blank"
                                    >COMMUNITY SOLUTIONS</a
                                >
                                <br />
                                <a href="https://alkeyword.com" class="button control" target="_blank"
                                    >CONTROL</a
                                >
                                <a href="https://bendscript.com" class="button power" target="_blank"
                                    >POWER</a
                                >
                                <br />
                                <a href="https://runefort.com" class="button game" target="_blank"
                                    >GAME</a
                                >
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            // Add these variables at the top of your script
            let mouseX = 0;
            let mouseY = 0;
            let hoveredBulb = null;
            let isMouseDown = false;
            let clickedBulb = null; // Track the clicked/dragged bulb
            let isDragging = false; // Track if we're currently dragging
            let stationaryBulb = null; // Track the stationary bulb that attracts others
            let dragOffsetX = 0; // Offset for dragging
            let dragOffsetY = 0; // Offset for dragging

            // Create a canvas for stars and effects
            const effectsCanvas = document.createElement("canvas");
            effectsCanvas.width = window.innerWidth;
            effectsCanvas.height = window.innerHeight;
            effectsCanvas.style.position = "absolute";
            effectsCanvas.style.top = "0";
            effectsCanvas.style.left = "0";
            effectsCanvas.style.zIndex = "1";
            document
                .getElementById("canvas-container")
                .appendChild(effectsCanvas);
            const effectsCtx = effectsCanvas.getContext("2d");

            // 2. Now add the event listeners right after creating the canvas:
            // Add mouse event listeners to the canvas
            effectsCanvas.addEventListener("mousemove", function (event) {
                mouseX = event.clientX;
                mouseY = event.clientY;

                // Handle dragging - only move the stationary bulb when explicitly dragging
                if (isDragging && clickedBulb && clickedBulb === stationaryBulb) {
                    // Update the dragged bulb position to follow mouse
                    Body.setPosition(clickedBulb, {
                        x: mouseX - dragOffsetX,
                        y: mouseY - dragOffsetY
                    });
                    // Ensure velocity remains zero while dragging
                    Body.setVelocity(clickedBulb, { x: 0, y: 0 });
                }

                // Check if mouse is over any lightbulb
                hoveredBulb = null;
                for (let i = 0; i < lightbulbs.length; i++) {
                    const bulb = lightbulbs[i];
                    const dx = mouseX - bulb.position.x;
                    const dy = mouseY - bulb.position.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < bulbSize) {
                        hoveredBulb = bulb;
                        effectsCanvas.style.cursor = "pointer";
                        break;
                    }
                }

                if (!hoveredBulb) {
                    effectsCanvas.style.cursor = "default";
                }
            });

            effectsCanvas.addEventListener("mousedown", function () {
                isMouseDown = true;
                if (hoveredBulb) {
                    clickedBulb = hoveredBulb;
                    
                    // Check if this is the first click on this bulb (make it stationary)
                    if (stationaryBulb !== clickedBulb) {
                        // If there was a previous stationary bulb, restore its movement
                        if (stationaryBulb) {
                            Body.setVelocity(stationaryBulb, {
                                x: (Math.random() - 0.5) * 3,
                                y: (Math.random() - 0.5) * 3,
                            });
                        }
                        
                        // Make this bulb stationary
                        stationaryBulb = clickedBulb;
                        Body.setVelocity(clickedBulb, { x: 0, y: 0 });
                        
                        // Calculate drag offset for smooth dragging
                        dragOffsetX = mouseX - clickedBulb.position.x;
                        dragOffsetY = mouseY - clickedBulb.position.y;
                    } else {
                        // Second click on the same bulb - start dragging
                        isDragging = true;
                        dragOffsetX = mouseX - clickedBulb.position.x;
                        dragOffsetY = mouseY - clickedBulb.position.y;
                    }
                }
            });

            effectsCanvas.addEventListener("mouseup", function () {
                if (isDragging && clickedBulb) {
                    // Stop dragging but keep the bulb stationary
                    isDragging = false;
                    Body.setVelocity(clickedBulb, { x: 0, y: 0 });
                }
                isMouseDown = false;
            });

            // Module aliases for Matter.js
            const Engine = Matter.Engine,
                Render = Matter.Render,
                Runner = Matter.Runner,
                Bodies = Matter.Bodies,
                Composite = Matter.Composite,
                Body = Matter.Body,
                Events = Matter.Events;

            // Create engine and world
            const engine = Engine.create({
                gravity: { x: 0, y: 0 }, // Zero gravity for space
            });
            const world = engine.world;

            // Create renderer
            const render = Render.create({
                element: document.getElementById("canvas-container"),
                engine: engine,
                options: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    wireframes: false,
                    background: "transparent",
                    pixelRatio: window.devicePixelRatio,
                },
            });
            render.canvas.style.zIndex = "2";

            // Run the renderer
            Render.run(render);

            // Create a runner
            const runner = Runner.create();
            Runner.run(runner, engine);

            // Lightbulb data structure
            const lightbulbs = [];
            // Same color for all lightbulbs
            const bulbColor = "#87CEEB"; // Light blue color

            // Connection distance threshold - increased for larger bulbs
            const connectionDistance = 300;

            // MODIFIED: Increase size by 2.5 times - adjusted SVG paths
            const bulbSize = 50; // Original was 20, now 50 (2.5x larger)

            // SVG lightbulb path (scaled up 2.5x from original)
            const lightbulbSVG = {
                // SVG data for a proper lightbulb shape - scaled up 2.5x
                bulbPath:
                    "M0,-50 C-27.5,-50 -50,-27.5 -50,0 C-50,27.5 -27.5,50 0,50 C27.5,50 50,27.5 50,0 C50,-27.5 27.5,-50 0,-50",
                basePath: "M-17.5,50 L-17.5,70 L17.5,70 L17.5,50",
                filamentPath: "M-12.5,0 C-12.5,-12.5 12.5,-12.5 12.5,0",
            };

            // Modify the createLightbulb function to include a hovered property
            function createLightbulb(x, y, number) {
                // Convert number to 3-digit binary
                const binaryStr = number.toString(2).padStart(3, "0");

                // Glass bulb (main body) - 2.5x larger radius
                const bulb = Bodies.circle(x, y, bulbSize, {
                    friction: 0,
                    frictionAir: 0, // No air friction for infinite movement
                    restitution: 1,
                    render: {
                        fillStyle: bulbColor,
                        opacity: 0.7,
                    },
                });

                // Add properties for drawing glow and binary digits later
                bulb.color = bulbColor;
                bulb.glowIntensity = 0.7;
                bulb.binaryStr = binaryStr;
                bulb.isHovered = false; // Add this property

                lightbulbs.push(bulb);
                return bulb;
            }

            // MODIFIED: Create only 8 lightbulbs (numbered 0-7)
            for (let i = 0; i < 8; i++) {
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;

                const lightbulb = createLightbulb(x, y, i);

                // Add random velocity
                Body.setVelocity(lightbulb, {
                    x: (Math.random() - 0.5) * 3,
                    y: (Math.random() - 0.5) * 3,
                });

                Composite.add(world, lightbulb);
            }

            // Setup for the bouncing card
            const cardContainer = document.querySelector(".card-container");
            const card = document.querySelector(".card");
            const overlayWidth = cardContainer.offsetWidth;
            const overlayHeight = cardContainer.offsetHeight;

            // Card flip control
            let isFlipped = false;
            let canFlip = true;
            const flipCooldown = 700; // Slightly longer than animation duration

            // Add card flip event listeners
            cardContainer.addEventListener("mouseenter", function() {
                if (canFlip && !isFlipped) {
                    isFlipped = true;
                    canFlip = false;
                    card.classList.add("flipped");
                    
                    // Re-enable flipping after animation completes
                    setTimeout(() => {
                        canFlip = true;
                    }, flipCooldown);
                }
            });

            cardContainer.addEventListener("mouseleave", function() {
                // Add a small delay before allowing flip back to prevent accidental toggling
                setTimeout(() => {
                    if (canFlip && isFlipped) {
                        isFlipped = false;
                        canFlip = false;
                        card.classList.remove("flipped");
                        
                        // Re-enable flipping after animation completes
                        setTimeout(() => {
                            canFlip = true;
                        }, flipCooldown);
                    }
                }, 100);
            });

            // Alternative: Click to flip (more stable)
            cardContainer.addEventListener("click", function() {
                if (canFlip) {
                    isFlipped = !isFlipped;
                    canFlip = false;
                    
                    if (isFlipped) {
                        card.classList.add("flipped");
                    } else {
                        card.classList.remove("flipped");
                    }
                    
                    // Re-enable flipping after animation completes
                    setTimeout(() => {
                        canFlip = true;
                    }, flipCooldown);
                }
            });

            // Initial position and velocity for the overlay
            let overlayX = Math.random() * (window.innerWidth - overlayWidth);
            let overlayY = Math.random() * (window.innerHeight - overlayHeight);
            let overlayVX = 0.75; // X velocity
            let overlayVY = 0.5; // Y velocity

            // Apply initial position
            cardContainer.style.left = `${overlayX}px`;
            cardContainer.style.top = `${overlayY}px`;

            // Star data with direction for movement
            const stars = [];
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    radius: Math.random() * 1.5 + 0.5,
                    opacity: Math.random() * 0.8 + 0.2,
                    twinkleSpeed: Math.random() * 0.05 + 0.01,
                    // Add very slow movement to stars
                    vx: (Math.random() - 0.5) * 0.1,
                    vy: (Math.random() - 0.5) * 0.1,
                });
            }

            // Add before update event to handle wrap-around and gravitational effects
            Events.on(engine, "beforeUpdate", function () {
                const width = window.innerWidth;
                const height = window.innerHeight;

                // Apply gravitational forces
                for (let i = 0; i < lightbulbs.length; i++) {
                    const bulb = lightbulbs[i];
                    
                    // Skip all physics for stationary bulb - it should be completely static
                    if (bulb === stationaryBulb) {
                        // Ensure stationary bulb has zero velocity at all times
                        Body.setVelocity(bulb, { x: 0, y: 0 });
                        continue;
                    }
                    
                    // Apply gravitational attraction to stationary bulb or mouse
                    if (stationaryBulb) {
                        const dx = stationaryBulb.position.x - bulb.position.x;
                        const dy = stationaryBulb.position.y - bulb.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0 && distance < 300) { // Reduced gravitational range
                            // Much weaker force with better damping at close range
                            const force = Math.min(0.0002 * (300 - distance) / distance, 0.01);
                            
                            // Apply force with velocity damping to prevent chaos
                            Body.applyForce(bulb, bulb.position, {
                                x: dx * force,
                                y: dy * force
                            });
                            
                            // Add velocity damping when close to stationary bulb
                            if (distance < 100) {
                                const velocity = bulb.velocity;
                                const damping = 0.95;
                                Body.setVelocity(bulb, {
                                    x: velocity.x * damping,
                                    y: velocity.y * damping
                                });
                            }
                        }
                    } else if (isMouseDown) {
                        // Apply gravitational attraction to mouse when clicking
                        const dx = mouseX - bulb.position.x;
                        const dy = mouseY - bulb.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0 && distance < 200) { // Reduced range for mouse attraction
                            const force = Math.min(0.0001 * (200 - distance) / distance, 0.005);
                            Body.applyForce(bulb, bulb.position, {
                                x: dx * force,
                                y: dy * force
                            });
                        }
                    }
                    
                    // Apply gentle orbital motion around stationary bulb
                    if (stationaryBulb && bulb !== stationaryBulb) {
                        const dx = stationaryBulb.position.x - bulb.position.x;
                        const dy = stationaryBulb.position.y - bulb.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 80 && distance < 250) { // Reduced orbital range
                            // Calculate perpendicular force for orbital motion
                            const perpX = -dy / distance;
                            const perpY = dx / distance;
                            const orbitalForce = 0.0005; // Much weaker orbital force
                            
                            Body.applyForce(bulb, bulb.position, {
                                x: perpX * orbitalForce,
                                y: perpY * orbitalForce
                            });
                        }
                    }
                }

                // Check each lightbulb position and wrap if needed
                for (let i = 0; i < lightbulbs.length; i++) {
                    const bulb = lightbulbs[i];
                    const bulbX = bulb.position.x;
                    const bulbY = bulb.position.y;

                    // Skip all position maintenance for stationary bulb
                    if (bulb === stationaryBulb) continue;

                    // Wrap horizontally - adjusted for larger size
                    if (bulbX < -120) {
                        Body.setPosition(bulb, {
                            x: width + 120,
                            y: bulbY,
                        });
                    } else if (bulbX > width + 120) {
                        Body.setPosition(bulb, {
                            x: -120,
                            y: bulbY,
                        });
                    }

                    // Wrap vertically - adjusted for larger size
                    if (bulbY < -120) {
                        Body.setPosition(bulb, {
                            x: bulbX,
                            y: height + 120,
                        });
                    } else if (bulbY > height + 120) {
                        Body.setPosition(bulb, {
                            x: bulbX,
                            y: -120,
                        });
                    }

                    // Maintain constant velocity (to counteract any slowdowns)
                    // Skip for stationary bulb
                    if (bulb === stationaryBulb) continue;
                    
                    const velocity = bulb.velocity;
                    const speed = Math.sqrt(
                        velocity.x * velocity.x + velocity.y * velocity.y,
                    );

                    // Limit maximum speed to prevent chaos
                    const maxSpeed = 4;
                    if (speed > maxSpeed) {
                        const scale = maxSpeed / speed;
                        Body.setVelocity(bulb, {
                            x: velocity.x * scale,
                            y: velocity.y * scale,
                        });
                    }

                    // Only boost if speed drops below original level
                    if (speed < 2) {
                        const direction = {
                            x: velocity.x / speed,
                            y: velocity.y / speed,
                        };

                        Body.setVelocity(bulb, {
                            x: direction.x * 3,
                            y: direction.y * 3,
                        });
                    }
                }
            });

            // Function to draw a path with transformation
            function drawPath(ctx, path, x, y, rotation = 0) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);

                const pathData = new Path2D(path);
                ctx.fill(pathData);

                ctx.restore();
            }

            // Update overlay position (bouncing effect)
            function updateOverlayPosition() {
                // Move the overlay according to its velocity
                overlayX += overlayVX;
                overlayY += overlayVY;

                // Get current window dimensions
                const maxX = window.innerWidth - overlayWidth;
                const maxY = window.innerHeight - overlayHeight;

                // Bounce off the edges
                if (overlayX <= 0) {
                    overlayX = 0;
                    overlayVX = Math.abs(overlayVX);
                } else if (overlayX >= maxX) {
                    overlayX = maxX;
                    overlayVX = -Math.abs(overlayVX);
                }

                if (overlayY <= 0) {
                    overlayY = 0;
                    overlayVY = Math.abs(overlayVY);
                } else if (overlayY >= maxY) {
                    overlayY = maxY;
                    overlayVY = -Math.abs(overlayVY);
                }

                // Apply the new position
                cardContainer.style.left = `${overlayX}px`;
                cardContainer.style.top = `${overlayY}px`;

                // Add a slight rotation based on direction
                const angle =
                    Math.atan2(overlayVY, overlayVX) * (180 / Math.PI);
                cardContainer.style.transform = `rotate(${angle * 0.05}deg)`;

                // Schedule the next update
                requestAnimationFrame(updateOverlayPosition);
            }

            // Start the overlay animation
            updateOverlayPosition();

            // Animation function for stars, glows, letters, and connections
            function animate() {
                // Clear the canvas
                effectsCtx.clearRect(
                    0,
                    0,
                    effectsCanvas.width,
                    effectsCanvas.height,
                );

                // Update and draw stars
                for (let i = 0; i < stars.length; i++) {
                    const star = stars[i];

                    // Move the star
                    star.x += star.vx;
                    star.y += star.vy;

                    // Wrap the stars when they go off screen
                    if (star.x < 0) star.x = effectsCanvas.width;
                    if (star.x > effectsCanvas.width) star.x = 0;
                    if (star.y < 0) star.y = effectsCanvas.height;
                    if (star.y > effectsCanvas.height) star.y = 0;

                    // Twinkle effect
                    star.opacity =
                        0.2 +
                        (Math.sin(Date.now() * star.twinkleSpeed) + 1) * 0.4;

                    effectsCtx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                    effectsCtx.beginPath();
                    effectsCtx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                    effectsCtx.fill();
                }

                // MODIFIED: Draw gold connections between nearby lightbulbs
                for (let i = 0; i < lightbulbs.length; i++) {
                    const bulb1 = lightbulbs[i];

                    for (let j = i + 1; j < lightbulbs.length; j++) {
                        const bulb2 = lightbulbs[j];

                        // Calculate distance between bulbs
                        const dx = bulb1.position.x - bulb2.position.x;
                        const dy = bulb1.position.y - bulb2.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // Draw connection if the bulbs are close enough
                        if (distance < connectionDistance) {
                            // Adjust opacity based on distance
                            const opacity = 1 - distance / connectionDistance;

                            // MODIFIED: Changed connections to brown
                            effectsCtx.strokeStyle = `rgba(139, 69, 19, ${opacity * 0.7})`;
                            effectsCtx.lineWidth = 3; // Slightly thicker brown lines
                            effectsCtx.beginPath();
                            effectsCtx.moveTo(
                                bulb1.position.x,
                                bulb1.position.y,
                            );
                            effectsCtx.lineTo(
                                bulb2.position.x,
                                bulb2.position.y,
                            );
                            effectsCtx.stroke();
                        }
                    }
                }

                // Draw each lightbulb using SVG paths
                for (let i = 0; i < lightbulbs.length; i++) {
                    const bulb = lightbulbs[i];
                    const intensity =
                        0.5 + Math.sin(Date.now() * 0.002 + i) * 0.2;

                    // Check if this bulb is being hovered over
                    bulb.isHovered = hoveredBulb === bulb;
                    
                    // Check if this is the stationary bulb
                    const isStationary = bulb === stationaryBulb;

                    // Set the bulb color based on state
                    let currentBulbColor;
                    if (isStationary) {
                        currentBulbColor = "#FFD700"; // Gold for stationary bulb
                    } else if (bulb.isHovered) {
                        currentBulbColor = "#FF0000"; // Red if hovered
                    } else {
                        currentBulbColor = bulbColor; // Light blue otherwise
                    }

                    // Parse color to RGB for glow
                    let r, g, b;
                    if (isStationary) {
                        // Gold color (255, 215, 0)
                        r = 255;
                        g = 215;
                        b = 0;
                    } else if (bulb.isHovered) {
                        // Red color when hovered (255, 0, 0)
                        r = 255;
                        g = 0;
                        b = 0;
                    } else {
                        // Original light blue color
                        r = 135;
                        g = 206;
                        b = 235;
                    }

                    // Create radial gradient for glow - scaled up for larger bulbs
                    const gradient = effectsCtx.createRadialGradient(
                        bulb.position.x,
                        bulb.position.y,
                        12.5, // Scaled up
                        bulb.position.x,
                        bulb.position.y,
                        isStationary ? 150 : 100, // Larger glow for stationary bulb
                    );

                    const glowMultiplier = isStationary ? 1.5 : 1.0; // Stronger glow for stationary bulb
                    gradient.addColorStop(
                        0,
                        `rgba(${r}, ${g}, ${b}, ${0.7 * intensity * bulb.glowIntensity * glowMultiplier})`,
                    );
                    gradient.addColorStop(1, "rgba(0, 0, 0, 0)");

                    effectsCtx.fillStyle = gradient;
                    effectsCtx.beginPath();
                    effectsCtx.arc(
                        bulb.position.x,
                        bulb.position.y,
                        isStationary ? 150 : 100, // Larger glow for stationary bulb
                        0,
                        Math.PI * 2,
                    );
                    effectsCtx.fill();

                    // Draw glass bulb using SVG path - using current color based on state
                    effectsCtx.fillStyle = currentBulbColor;
                    drawPath(
                        effectsCtx,
                        lightbulbSVG.bulbPath,
                        bulb.position.x,
                        bulb.position.y,
                    );

                    // Draw a metal base using SVG path
                    let baseColor;
                    if (isStationary) {
                        baseColor = "#FFD700"; // Gold base for stationary bulb
                    } else if (bulb.isHovered) {
                        baseColor = "rgba(0, 128, 0, 1)"; // Green if hovered
                    } else {
                        baseColor = "#777"; // Grey normally
                    }
                    effectsCtx.fillStyle = baseColor;
                    drawPath(
                        effectsCtx,
                        lightbulbSVG.basePath,
                        bulb.position.x,
                        bulb.position.y,
                    );

                    // Add glow lines around the bulb - scaled up
                    const glowIntensity =
                        0.4 + Math.sin(Date.now() * 0.003 + i) * 0.2;

                    // Change glow lines color based on state
                    let glowColor;
                    if (isStationary) {
                        glowColor = `rgba(255, 215, 0, ${glowIntensity * 1.5})`; // Bright gold for stationary
                    } else if (bulb.isHovered) {
                        glowColor = `rgba(128, 128, 128, ${glowIntensity})`; // Grey glow when hovered
                    } else {
                        glowColor = `rgba(255, 215, 0, ${glowIntensity})`; // Gold glow normally
                    }

                    effectsCtx.strokeStyle = glowColor;
                    effectsCtx.lineWidth = isStationary ? 3 : 2; // Thicker lines for stationary bulb

                    // Draw 3 concentric circles with varying radii for glow effect - scaled up
                    const baseRadius = isStationary ? 75 : 62.5; // Larger radius for stationary bulb
                    const maxRadius = isStationary ? 100 : 87.5; // Larger max radius for stationary bulb
                    for (let radius = baseRadius; radius <= maxRadius; radius += 12.5) {
                        effectsCtx.beginPath();
                        effectsCtx.arc(
                            bulb.position.x,
                            bulb.position.y,
                            radius,
                            0,
                            Math.PI * 2,
                        );
                        effectsCtx.stroke();
                    }

                    // Draw binary digits with color based on state
                    let textColor;
                    if (isStationary) {
                        textColor = "#FF0000"; // Red text for stationary bulb
                    } else if (bulb.isHovered) {
                        textColor = "#FFFF00"; // Yellow text if hovered
                    } else {
                        textColor = "purple"; // Purple normally
                    }
                    
                    effectsCtx.fillStyle = textColor;
                    effectsCtx.font = isStationary ? "bold 24px monospace" : "bold 20px monospace"; // Larger font for stationary bulb
                    effectsCtx.textAlign = "center";
                    effectsCtx.textBaseline = "middle";

                    // Position the digits vertically inside the bulb
                    const digits = bulb.binaryStr.split("");
                    const yOffset = isStationary ? 18 : 15; // Slightly larger spacing for stationary bulb
                    effectsCtx.fillText(
                        digits[0],
                        bulb.position.x,
                        bulb.position.y - yOffset,
                    );
                    effectsCtx.fillText(
                        digits[1],
                        bulb.position.x,
                        bulb.position.y,
                    );
                    effectsCtx.fillText(
                        digits[2],
                        bulb.position.x,
                        bulb.position.y + yOffset,
                    );
                }

                requestAnimationFrame(animate);
            }

            // Start animation
            animate();

            // Button glow animation
            setInterval(() => {
                const button = document.querySelector(".button");
                const currentGlow = Math.floor(Math.random() * 5) + 5; // Random glow between 5-10px
                button.style.boxShadow = `0 0 ${currentGlow}px rgba(135, 206, 235, 0.8)`;
            }, 1000);

            // Handle window resize
            window.addEventListener("resize", function () {
                // Update canvases
                render.canvas.width = window.innerWidth;
                render.canvas.height = window.innerHeight;
                effectsCanvas.width = window.innerWidth;
                effectsCanvas.height = window.innerHeight;

                // Update renderer
                render.options.width = window.innerWidth;
                render.options.height = window.innerHeight;

                // Make sure the overlay stays within bounds after resize
                const maxX = window.innerWidth - overlayWidth;
                const maxY = window.innerHeight - overlayHeight;

                if (overlayX > maxX) {
                    overlayX = maxX;
                    cardContainer.style.left = `${overlayX}px`;
                }

                if (overlayY > maxY) {
                    overlayY = maxY;
                    cardContainer.style.top = `${overlayY}px`;
                }
            });
        </script>
    </body>
</html>
